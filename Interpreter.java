package assignment01;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.MissingFormatArgumentException;
import java.util.Optional;
import java.util.TreeMap;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

public class Interpreter {
	public class LineManager {
		private List<String> readInput;

		LineManager(List<String> readInput) {
			this.readInput = readInput;

			// when a new files is being read FNR resets
			FNR = 0;
			globalVariables.put("FNR", new InterpreterDataType(Integer.toString(FNR)));
		}

		public boolean splitAndAssign() {
			// if theres no data there are no lines to split
			if (!readInput.isEmpty()) {
				NF = 0;
				NR++;
				FNR++;

				var currentLine = readInput.get(0);

				// go through fields generated by split, creating $s based on NF (barring $0)
				for (String field : currentLine.split(globalVariables.get("FS").getData())) {
					NF++;
					globalVariables.put("$" + NF, new InterpreterDataType(field));
				}

				// if any fields were found in the line -> set $0 and remove that line from list
				if (NF < 1) {
					return false;
				} else {
					globalVariables.put("$0", new InterpreterDataType(currentLine));

					globalVariables.put("NF", new InterpreterDataType(Integer.toString(NF)));
					globalVariables.put("NR", new InterpreterDataType(Integer.toString(NR)));
					globalVariables.put("FNR", new InterpreterDataType(Integer.toString(FNR)));

					readInput.remove(0);
					return true;
				}
			} else {
				return false;
			}
		}
	}

	private int NF; // Fields in current line
	private int NR; // Total line number
	private int FNR; // Current File's line number

	private HashMap<String, InterpreterDataType> globalVariables;
	private HashMap<String, DefineFunction> functions; // created a defineFunction interface and applied as needed
	private LineManager lineManager;
	private ProgramNode program;

	Interpreter(ProgramNode pNode) {
		NF = 0;
		NR = 0;
		FNR = 0;

		globalVariables = new HashMap<>();
		functions = new HashMap<>();
		
		program = pNode;

		globalVariables.put("FS", new InterpreterDataType(" "));
		globalVariables.put("OFMT", new InterpreterDataType("%.6g"));
		globalVariables.put("OFS", new InterpreterDataType(" "));
		globalVariables.put("ORS", new InterpreterDataType("\n"));

		program.getFunctions().forEach(function -> functions.put(function.getName(), function));
		initializeBuiltIns();

		lineManager = new LineManager(new LinkedList<>());
	}

	Interpreter(ProgramNode pNode, Path file) throws IOException {
		this(pNode);
		lineManager = new LineManager(Files.readAllLines(file));
		globalVariables.put("FILENAME", new InterpreterDataType(file.toString()));
	}
	
	public void interpretProgram() {
		for(BlockNode block : program.getBeginBlocks()) {
			interpretBlock(block);
		}
		
		while(lineManager.splitAndAssign()) {
			for(BlockNode block : program.getOtherBlocks()) {
				interpretBlock(block);
			}
		}
		
		for(BlockNode block : program.getEndBlocks()) {
			interpretBlock(block);
		}
	}
	
	private void interpretBlock(BlockNode block) {
		var blockCon = block.getCondition();
		
		// if not empty it will always be present in which case we evaluate it
		if(blockCon.isEmpty() || boolOfIDT(getIDT(blockCon.get(), null))) {
			for(StatementNode statement : block.getStatementNodes()) {
				processStatement(statement, null);
			}
		}
	}
	
	// checks local map -> if null or not present return false;
	private boolean variablePresent(HashMap<String, InterpreterDataType> variables, String someVar) {
		return (variables == null) ? false : variables.containsKey(someVar);
	}

	private InterpreterDataType inOperations(OperationNode node, HashMap<String, InterpreterDataType> localVars) {
		if (node.getOperator() != operations.IN) {	//end of the line, no other possible operations can be done
			throw new IllegalArgumentException("Unrecognized operator");
		}
		Optional<Node> right = node.getRight();

		if (right.isPresent() && right.get() instanceof VariableReferenceNode vrNode) {
			if (getIDT(vrNode, localVars) instanceof InterpreterArrayDataType IADT) {	//if index is a reference just use it else calculate it
				String left = (node.getLeft() instanceof VariableReferenceNode v) ? v.getName() : getIDT(node.getLeft(), null).getData();
	
				return new InterpreterDataType(IADT.getMap().containsKey(left) ? "1" : "0");
			} else {
				throw new IllegalArgumentException("'In' MUST be used on an array");
			}
		} else {
			throw new IllegalArgumentException("'In' MUST be used on an array");
		}
	}

	private InterpreterDataType mathOperations(OperationNode node, HashMap<String, InterpreterDataType> localVars) {
		BinaryOperator<Float> mathOp;
		
		switch (node.getOperator()) {
		case ADD:
			mathOp = (a, b) -> a + b;
			break;
		case SUBTRACT:
			mathOp = (a, b) -> a - b;
			break;
		case MULTIPLY:
			mathOp = (a, b) -> a * b;
			break;
		case DIVIDE:
			mathOp = (a, b) -> a / b;
			break;
		case MODULO:
			mathOp = (a, b) -> a % b;
			break;
		case EXPONENT:
			mathOp = (a, b) -> (float) Math.pow(a, b);
			break;
		default:
			return compareOperations(node, localVars);
		}

		InterpreterDataType left = getIDT(node.getLeft(), localVars);	//do the left
		InterpreterDataType right = null;

		if (node.getRight().isPresent()) {	// if theres a right do it
			right = getIDT(node.getRight().get(), localVars);
		}	
		
		// apply the operation with the parsed values
		float result = mathOp.apply(parseFloat(left), parseFloat(right));
		
		return new InterpreterDataType(formatNumber(result));
	}
	
	private String formatNumber(float num) {
		// doesnt catch errors because will be used in tandem with parseFloat which does
		// if a float % 1 = 0; then it defitinetly can be casted to an int
		return ((num % 1) != 0) ? String.valueOf(num) : String.valueOf((int) num);
	}
	
	private float parseFloat(InterpreterDataType IDT) {
		// if a variable doesnt exist, one will NOT be created, instead it will be given a default value to 0
		try {
			return Float.parseFloat(IDT.getData());
		} catch (NumberFormatException | NullPointerException e) {
			//strings, unitialized variables, and 0 -> all return 0 
			return 0;
		}
	}
	
	private boolean boolOfIDT(InterpreterDataType idt) {		
		// anything parsed to 0 will return false
		return (parseFloat(idt) != 0) ? true : false;
	}
	
	public int timesInString(String searchIn, String searchFor) {
		int count = 0;
		int prevIndex = 0;

		while (prevIndex != -1) {
			prevIndex = searchIn.indexOf(searchFor, prevIndex);

			if (prevIndex != -1) {
				count++;
				prevIndex += searchFor.length();
			}
		}
		return count;
	}
	
	private InterpreterDataType applyCompare(InterpreterDataType left, InterpreterDataType right, BiFunction<Float, Float, Boolean> operation) {
		float leftAsFloat;
		float rightAsFloat;
		
		try {
			leftAsFloat = Float.parseFloat(left.getData());
			rightAsFloat = Float.parseFloat(right.getData());
		} catch (NumberFormatException | NullPointerException e) {
			leftAsFloat = left.getData().compareTo(right.getData());
			rightAsFloat = 0f;
		} 

		String result = Boolean.TRUE.equals(operation.apply(leftAsFloat, rightAsFloat)) ? "1" : "0";
		return new InterpreterDataType(result);
	}

	private InterpreterDataType compareOperations(OperationNode node, HashMap<String, InterpreterDataType> localVars) {
		BiFunction<Float, Float, Boolean> compareOp;
		switch (node.getOperator()) {
		case EQ:
			compareOp = Object::equals;
			break;
		case NE:
			compareOp = (a, b) -> !a.equals(b);
			break;
		case LT:
			compareOp = (a, b) -> a < b;
			break;
		case LE:
			compareOp = (a, b) -> a <= b;
			break;
		case GT:
			compareOp = (a, b) -> a > b;
			break;
		case GE:
			compareOp = (a, b) -> a >= b;
			break;
		default:
			return booleanOperations(node, localVars);
		}
		
		// same as previous -> parse then apply
		InterpreterDataType left = getIDT(node.getLeft(), localVars);	
		InterpreterDataType right = null;

		if (node.getRight().isPresent()) {
			right = getIDT(node.getRight().get(), localVars);
		}
		return applyCompare(left, right, compareOp);
	}

	private InterpreterDataType booleanOperations(OperationNode node, HashMap<String, InterpreterDataType> localVars) {
		BiFunction<Boolean, Boolean, Boolean> booleanOp;

		switch (node.getOperator()) {
		case AND:
			booleanOp = (a,b) -> a && b;
			break;
		case OR:
			booleanOp = (a,b) -> a || b;
			break;
		case NOT:	//not is single var operation 
			InterpreterDataType left = getIDT(node.getLeft(), localVars);
			return new InterpreterDataType(parseFloat(left) != 0 ? "0" : "1");	// return the inverse
		default:
			return matchOperations(node, localVars);
		}
		
		InterpreterDataType left = getIDT(node.getLeft(), localVars);
		InterpreterDataType right = null;

		if (node.getRight().isPresent()) {
			right = getIDT(node.getRight().get(), localVars);
		}
		
		// if they arent a string or equal 0 then they are true statemetns
		boolean leftAsBool = parseFloat(left) != 0;
		boolean rightAsBool = parseFloat(right) != 0;
		
		String x = Boolean.TRUE.equals(booleanOp.apply(leftAsBool, rightAsBool)) ? "1" : "0";
		return new InterpreterDataType(x);
	}

	private InterpreterDataType matchOperations(OperationNode node, HashMap<String, InterpreterDataType> localVars) {
		boolean lookForMatch;
		
		switch (node.getOperator()) {
		case MATCH:
			lookForMatch = true;
			break;
		case NOTMATCH:
			lookForMatch = false;
			break;
		default:
			return dollarOperations(node, localVars);
		}
		InterpreterDataType left = getIDT(node.getLeft(), localVars);

		Optional<Node> right = node.getRight();	//there MUST be a pattern node to the right
		if (right.isPresent() && right.get() instanceof PatternNode pNode) {
			String x = left.getData().matches(pNode.getPattern()) == lookForMatch ? "1" : "0";
			return new InterpreterDataType(x);
		} else {
			throw new IllegalArgumentException("Only Patterns denoted by / /(This case: ` `) are allowed");
		}
	}
	
	private InterpreterDataType dollarOperations(OperationNode node, HashMap<String, InterpreterDataType> localVars) {
		if (node.getOperator() != operations.DOLLAR) {
			return singleVariableOperations(node, localVars);
		}
		return globalVariables.get("$" + getIDT(node.getLeft(), localVars)); // $ is in reference to fields which are always global
	}
	
	private InterpreterDataType singleVariableOperations(OperationNode node,HashMap<String, InterpreterDataType> localVars) {
		Function<Float, Float> singleVarOp;
		boolean pre;
		switch (node.getOperator()) {
		case UNARYPOS:
			singleVarOp = a -> +a; // does nothing
			pre = true;
			break;
		case UNARYNEG:
			singleVarOp = a -> -a;
			pre = true;
			break;
		case POSTDEC:
			singleVarOp = a -> a - 1; 
			pre = false;
			break;
		case PREDEC:
			singleVarOp = a -> a - 1; 
			pre = true;
			break;
		case POSTINC:
			singleVarOp = a -> a + 1; 
			pre = false;
			break;
		case PREINC:
			singleVarOp = a -> a + 1; 
			pre = true;
			break;
		default:
			return concatenationOperations(node, localVars);
		}
		
		// same as previous just on one target instead of two
		// if its pre set it and use the new value, else set it but use old
		InterpreterDataType oldVar = getIDT(node.getLeft(), localVars);

		String oldNum = oldVar.getData();
		String newNum = formatNumber(singleVarOp.apply(parseFloat(oldVar)));

		oldVar.setData(newNum);
		return new InterpreterDataType(pre ? newNum : oldNum);
	}

	private InterpreterDataType concatenationOperations(OperationNode node,HashMap<String, InterpreterDataType> localVars) {
		if (node.getOperator() != operations.CONCATENATION) {
			return inOperations(node, localVars);
		}

		String left = getIDT(node.getLeft(), localVars).getData();
		String right = "";

		if (node.getRight().isPresent()) {
			right = getIDT(node.getRight().get(), localVars).getData();
		}
		return new InterpreterDataType(left + right);
	}
	
	public InterpreterDataType getIDT(Node node, HashMap<String, InterpreterDataType> localVars) {
		if (node instanceof AssignmentNode aNode) {	
			return doAssignmentNode(aNode, localVars);
		}
		else if (node instanceof ConstantNode cNode) {
			return new InterpreterDataType(cNode.getValue());
		}
		else if (node instanceof FunctionCallNode fNode) {
			return new InterpreterDataType(runFunctionCall(fNode, localVars));
		}
		else if (node instanceof PatternNode) {
			throw new IllegalArgumentException("Patterns are not allowed in this context");
		}
		else if (node instanceof TernaryNode tNode) {	
			String bool = getIDT(tNode.getBooleanCondition(), localVars).getData();	// get condition
			// check if that condition is true, return truecase -> else false case
			return bool.equals("1") ? getIDT(tNode.getTrueCase(), localVars) : getIDT(tNode.getFalseCase(), localVars); // ironic
		}
		else if (node instanceof VariableReferenceNode vNode) {
			var location = (variablePresent(localVars, vNode.getName()) ? localVars : globalVariables);	// find the location in which the array is present
			InterpreterDataType ref = location.get(vNode.getName());
			if (vNode.getExpression().isPresent()) {
				if ((ref instanceof InterpreterArrayDataType IADT)) {	//only tries to get an index IF its an IADT
					Node indexOperation = vNode.getExpression().get();
					String index = getIDT(indexOperation, location).getData();
					
					return IADT.getMap().get(index);
				} else {
					throw new IllegalArgumentException("Not an array type");
				}
			} else {
				return ref;
			}
		}
		else if (node instanceof OperationNode opNode) {
			return mathOperations(opNode, localVars);
		}
		else {
			return null;
		}
	}
	
	private InterpreterDataType doAssignmentNode(AssignmentNode node, HashMap<String, InterpreterDataType> localVars) {
		Node target = node.getTarget();
		String key;
		
		// check if the left side is valid for assignments
		if(target instanceof VariableReferenceNode vNode) {
			key = vNode.getName();
		}else if(target instanceof OperationNode opNode && opNode.getOperator() == operations.DOLLAR) {
			key = "$" + getIDT(opNode.getLeft(), localVars);
		}
		else {
			throw new IllegalArgumentException("Leftside of expression invalid: " + node.toString());
		}
		
		InterpreterDataType result = getIDT(node.getExpression(), localVars);
		var location = (localVars != null ? localVars : globalVariables);
		
		if(target instanceof VariableReferenceNode v && v.getExpression().isPresent()) {
			var data = (InterpreterArrayDataType) location.computeIfAbsent(key, x -> new InterpreterArrayDataType());
			data.getMap().put(getIDT(v.getExpression().get(),localVars).getData(), result);
		}else {
			(localVars != null ? localVars : globalVariables).put(key, new InterpreterDataType(result.getData())); // put new result in the appropriate map
		}
		return result;
	}
	
	public InterpreterArrayDataType setupIADT(String key, HashMap<String, InterpreterDataType> localVars) {
		var location = (localVars != null) ? localVars : globalVariables;
		var IADT = new InterpreterArrayDataType();
		location.put(key, IADT);
		return IADT;
	}
	
	public String runFunctionCall(FunctionCallNode fnCall, HashMap<String, InterpreterDataType> localVars) {
		String fnName = fnCall.getFunctionName();
		DefineFunction fnDef = functions.get(fnName); // retrieve the functions 'blueprint' to compare our call to
		
		if (fnDef == null) { // did not find a function with that name
			throw new IllegalArgumentException("Function '" + fnName + "' not defined");
		}
				
		var fnDefList =  fnDef.getParameterNames();
		var fnCallList = fnCall.getParams();
		
		//NOTE: Builtins are matched for size within the function itself 
		// if the call and definition do not match in parameters throw error
		if(!(fnDef instanceof BuiltInFunction) && fnCallList.size() != fnDefList.size()) {
			throw new IllegalArgumentException("Function '" + fnName + "' takes " + fnDefList.size() + " parameters");
		}
		
		var fnParams = new HashMap<String, InterpreterDataType>();
		int pos = 0;
		
		// put the parameters in my map
		for(String pName : fnDefList) {
			if(pos >= fnCallList.size()) {
				break;
			}
			var callName = fnCallList.get(pos++);
			var IDT = getIDT(callName, localVars);
														// only arrays can be null at this point, get the refName
			fnParams.put(pName, ((IDT != null) ? IDT : setupIADT(((VariableReferenceNode)callName).getName(), localVars))); 
		}
	
		// only our builtins are variadic
		if (fnDef instanceof BuiltInFunction builtInFn) {
			if (builtInFn.isVariadic()) { //if therese still more data in the fnCall then treat last as IADT
				var IADT = new InterpreterArrayDataType();
				
				for (int j = pos - 1; j < fnCallList.size(); j++) {
					IADT.getMap().put("key0" + j, getIDT(fnCallList.get(j), localVars)); //IADT key negligible (we can assume its in correct order)
				}
				fnParams.put(fnDefList.get(fnDefList.size() - 1), IADT);	// puts variadic array inplace of last var in map
			}
			return builtInFn.execute(fnParams);
		}
		else {
			return interpretListOfStatements(((FunctionDefinitionNode)fnDef).getStatements(),fnParams).getReturnValue();
		}
	}

	private void initializeBuiltIns() {
		Function<HashMap<String, InterpreterDataType>, String> print = param -> {
			// sorts the IADT by key ENSURING correct order
			var sortedMap = new TreeMap<>(((InterpreterArrayDataType) param.get("array")).getMap()); 
			
			StringBuilder sb = new StringBuilder();

			sortedMap.values().forEach(x -> sb.append(x + " "));
			
			System.out.println(sb); // printing in the function like it says in directions
			return null;
		};
		functions.put("print", new BuiltInFunction(print,new String[] {"array"}, true));

		Function<HashMap<String, InterpreterDataType>, String> printf = param -> {
			if (param.size() < 1) {
				throw new IllegalArgumentException("printf needs atleast 1 argument");
			}

			String format = "%s"; 
			var sortedMap = new TreeMap<>(((InterpreterArrayDataType) param.get("array")).getMap()); 

			String stringWithFormatters = param.get("string").getData();
			
			var list = new LinkedList<String>();
			
			if(sortedMap != null) {
				sortedMap.values().forEach(x -> list.add(x.getData()));
			}
			
			String[] stringsToFormat  = list.toArray(new String[0]);

			// the amount of values to format MUST be => present format specifier
			if (stringsToFormat.length < timesInString(stringWithFormatters, format)) {
				throw new MissingFormatArgumentException("format specifier not fulfilled");
			}

			System.out.printf(stringWithFormatters, stringsToFormat);
			return null; // return some value
		};
		functions.put("printf", new BuiltInFunction(printf,new String[] {"string", "array"}, true));

		// getline and next do the same thing in this context
		Function<HashMap<String, InterpreterDataType>, String> getLineOrNext = param -> {
			lineManager.splitAndAssign();
			return null; // no string needed
		};

		functions.put("getline", new BuiltInFunction(getLineOrNext, false));
		functions.put("next", new BuiltInFunction(getLineOrNext, false));

		// in Map: searches for 'in' and 'find'
		Function<HashMap<String, InterpreterDataType>, String> index = pMap -> {
			if (pMap.size() != 2) {
				throw new IllegalArgumentException(
						"index only takes 2 arguments: string to search - substring to find");
			}
			String searchIn = pMap.get("in").getData();
			String subToFind = pMap.get("find").getData();

			// Java's indexOf is always +1, than awk: notfound? awk = 0, java = -1. start?
			// awk = 1, java = 0...
			return Integer.toString(searchIn.indexOf(subToFind) + 1);
		};
		functions.put("index", new BuiltInFunction(index,new String[] {"in", "find"}, false));

		// in Map: searches for string
		Function<HashMap<String, InterpreterDataType>, String> length = pMap -> {
			if (pMap.size() != 1) {
				throw new IllegalArgumentException("length only takes 1 argument: string");
			}

			int size = pMap.get("string").getData().length();
			return Integer.toString(size);
		};
		functions.put("length", new BuiltInFunction(length, new String[] {"string"}, false));

		// in Map: searches for String & array |optional| fieldsep, seps
		Function<HashMap<String, InterpreterDataType>, String> split = pMap -> {
			if (pMap.size() < 2 || pMap.size() > 4) {
				throw new IllegalArgumentException(
						"split only takes 2-4 arguments: string to search - array to store substrings - (optional: default FS) seperator - (optional) array to store found seperators");
			}
			HashMap<String, InterpreterDataType> stringSplitted = new HashMap<>();

			String stringToSplit = pMap.get("string").getData();
			String seperator = pMap.containsKey("fieldsep") ? pMap.get("fieldsep").getData() : globalVariables.get("FS").getData();

			String[] splittedStrings = stringToSplit.split(seperator);

			for (int i = 0; i < splittedStrings.length; i++) {
				stringSplitted.put(Integer.toString(i), new InterpreterDataType(splittedStrings[i]));
			}
			
			((InterpreterArrayDataType)pMap.get("array")).setMap(stringSplitted);

			// if included set the array to all the deleted seperators
			if (pMap.containsKey("seps")) {
				HashMap<String, InterpreterDataType> removedSeps = new HashMap<>();
				int timesPresent = timesInString(stringToSplit, seperator);

				for (int i = 0; i < timesPresent; i++) {
					removedSeps.put(Integer.toString(i), new InterpreterDataType(seperator));
				}

				((InterpreterArrayDataType)pMap.get("seps")).setMap(removedSeps);
			}
			return Integer.toString(splittedStrings.length);
		};
		functions.put("split", new BuiltInFunction(split, new String[] {"string", "array", "fieldsep", "seps"}, false));

		// in Map: searches for String
		Function<HashMap<String, InterpreterDataType>, String> tolower = pMap -> {
			if (pMap.size() != 1) {
				throw new IllegalArgumentException("tolower only takes 1 argument: string");
			}
			String string = pMap.get("string").getData();
			return string.toLowerCase();
		};
		functions.put("tolower", new BuiltInFunction(tolower, new String[] {"string"}, false));

		// in Map: searches for String
		Function<HashMap<String, InterpreterDataType>, String> toupper = pMap -> {
			if (pMap.size() != 1) {
				throw new IllegalArgumentException("toupper only takes 1 argument: string");
			}
			String string = pMap.get("string").getData();
			return string.toUpperCase();
		};
		functions.put("toupper", new BuiltInFunction(toupper, new String[] {"string"}, false));


		// in Map: searches for String & Start |optional| length
		Function<HashMap<String, InterpreterDataType>, String> substr = pMap -> {
			if (pMap.size() != 2 && pMap.size() != 3) {
				throw new IllegalArgumentException(
						"substring takes 2-3 arguments: string - starting index - (optional) end index");
			}
			String searchInString = pMap.get("string").getData();

			try {
				int startIndex = Integer.parseInt(pMap.get("start").getData());

				// if length present, calculate the endIndex using it
				return (pMap.containsKey("length"))
						? searchInString.substring(startIndex - 1,
								(startIndex + Integer.parseInt(pMap.get("length").getData())) - 1)
						: searchInString.substring(startIndex - 1);
			} catch (NumberFormatException e) {
				throw new IllegalArgumentException("Arguments 2 or 3 are not valid numbers for this function");
			}
		};
		functions.put("substr", new BuiltInFunction(substr, new String[] {"string", "start", "length"}, false));

		// in Map: regexp & replacement |optional| target
		Function<HashMap<String, InterpreterDataType>, String> gsub = pMap -> {
			if (pMap.size() != 2 && pMap.size() != 3) {
				throw new IllegalArgumentException(
						"gsub takes 2-3 arguments: String/regex to search for - its replacement - (optional: default is $0) text");
			}
			String key = "$0";
			var map = globalVariables;

			if (pMap.containsKey("target")) {
				map = pMap;
				key = "target";
			}

			String searchPattern = pMap.get("regexp").getData();
			String replacement = pMap.get("replacement").getData();

			String originalString = map.get(key).getData();
			String newString = originalString.replaceAll(searchPattern, replacement);

			map.put(key, new InterpreterDataType(newString));

			return Integer.toString(timesInString(originalString, searchPattern));
		};
		functions.put("gsub", new BuiltInFunction(gsub, new String[] {"regexp", "replacement", "target"}, false));

		// in Map: searches for string & regexp |optional| array
		// array holds [0]full substring, [1] length of sub,[2] starting pos
		Function<HashMap<String, InterpreterDataType>, String> match = pMap -> {
			if (pMap.size() != 2 && pMap.size() != 3) {
				throw new IllegalArgumentException("match takes 2-3 arguments: string - rexep - (optional) array");
			}
			String string = pMap.get("string").getData();

			try {
				Pattern pattern = Pattern.compile(pMap.get("regexp").getData());
				Matcher matcher = pattern.matcher(string);

				int startIndex = matcher.find() ? matcher.start() + 1 : 0;

				if (pMap.containsKey("array")) {
					
					var map = ((InterpreterArrayDataType) pMap.get("array")).getMap();
					map.clear();

					if (startIndex > 0) {
						String matchedString = matcher.group();
						map.put("0", new InterpreterDataType(matchedString));
						map.put("1", new InterpreterDataType(Integer.toString(matchedString.length())));
						map.put("2", new InterpreterDataType(Integer.toString(startIndex)));
					}
				}
				return Integer.toString(startIndex); // pos where substring began
			} catch (PatternSyntaxException e) {
				throw new IllegalArgumentException("This is not a valid regexp");
			}
		};
		functions.put("match", new BuiltInFunction(match, new String[] {"string", "regexp", "array"}, false));

		// in Map: regexp & replacement |optional| target
		Function<HashMap<String, InterpreterDataType>, String> sub = pMap -> {
			if (pMap.size() != 2 && pMap.size() != 3) {
				throw new IllegalArgumentException(
						"sub takes 2-3 arguments: String/regex to search for - its replacement - (optional: default is $0) text");
			}
			String key = "$0";
			var map = globalVariables;

			if (pMap.containsKey("target")) {
				map = pMap;
				key = "target";
			}

			String searchPattern = pMap.get("regexp").getData();
			String replacement = pMap.get("replacement").getData();

			String originalString = map.get(key).getData();
			String newString = originalString.replaceFirst(searchPattern, replacement);

			boolean replacementMade = !newString.equals(originalString);
			map.put(key, new InterpreterDataType(newString));

			return replacementMade ? "1" : "0";
		};
		functions.put("sub", new BuiltInFunction(sub, new String[] {"regexp", "replacement", "target"}, false));
	}

	private ReturnType returnOfIfElse(IfElseNode ifNode, HashMap<String, InterpreterDataType> localVars) {
		Optional<Node> condition = ifNode.getCondition();
		
		// empty indicates 'else'; condition of if is true
		if (condition.isEmpty() || boolOfIDT(getIDT(condition.get(), localVars))) {
			return interpretListOfStatements(ifNode.getStatements(), localVars);
		} else if (ifNode.getNext().isPresent()) {
			return returnOfIfElse(ifNode.getNext().get(), localVars);
		} else {
			return new ReturnType(processes.NORMAL);
		}
	}
	
	// Public for testing
	public ReturnType processStatement(StatementNode stmt, HashMap<String, InterpreterDataType> localVars){
		if(stmt instanceof AssignmentNode aNode) {
			// function doAssignmentNode in getIDT handles the setting of a variable, and returns the right side
			return new ReturnType(processes.NORMAL, getIDT(aNode, localVars).getData()); 
		}
		else if(stmt instanceof BreakNode) {
			return new ReturnType(processes.BREAK);
		}
		else if(stmt instanceof ContinueNode) {
			return new ReturnType(processes.CONTINUE);
		}
		else if(stmt instanceof DeleteNode dNode) {
			VariableReferenceNode toDelete = dNode.getToDelete();
			
			// if theres an index attached to the array get IDT returns the value and not key to remove
			if(toDelete.getExpression().isPresent()) {
				var location = (variablePresent(localVars, toDelete.getName()) ? localVars : globalVariables).get(toDelete.getName());
				((InterpreterArrayDataType)location).getMap().remove(getIDT(toDelete.getExpression().get(), localVars).getData());
			}
			else {
				InterpreterDataType ref = getIDT(toDelete,localVars);
				((InterpreterArrayDataType)ref).getMap().clear();
			}
			return new ReturnType(processes.NORMAL);
		}
		else if(stmt instanceof WhileNode wNode) {
			// Both While and Do-While: runs if its a dowhile or if the starting condition is true
			if(wNode.isDoWhile() || boolOfIDT(getIDT(wNode.getCondition(), localVars))) {
				do {	// doesnt matter because if its not dowhile condition is initially checked
					ReturnType returnedVal = interpretListOfStatements(wNode.getStatements(), localVars);
					if(returnedVal.getProcess() == processes.BREAK) {
						break;
					}
					else if (returnedVal.getProcess() == processes.RETURN) {
						return returnedVal;
					}
				}
				while(boolOfIDT(getIDT(wNode.getCondition(), localVars)));
			}
			return new ReturnType(processes.NORMAL);
		}
		else if(stmt instanceof ForNode fNode) {
			// for(pt1; pt2; pt3)
			// pt1: initialize a variable
			if(fNode.getInitial().isPresent()) {
				processStatement((StatementNode)(fNode.getInitial().get()), localVars);
			}
			
			var loopCon = fNode.getCondition();
			
			// pt2: loop while the condition is true (if empty will loop indefinitely)
			while((loopCon.isPresent() ? boolOfIDT(getIDT(loopCon.get(), localVars)) : true)) {	
				ReturnType returnedVal = interpretListOfStatements(fNode.getStatements(), localVars);
	
				if(returnedVal.getProcess() == processes.BREAK) {
					break;
				}
				else if (returnedVal.getProcess() == processes.RETURN) {
					return returnedVal;
				}

				var incriment = fNode.getIncriment();
				
				// pt3: if theres a value to be incremented, do it
				if(incriment.isPresent()) {
					processStatement((StatementNode)(incriment.get()), localVars);
				}
			}
			return new ReturnType(processes.NORMAL); 
		}
		else if (stmt instanceof ForEachNode feNode) { 
			// In parser: foreach can ONLY be an operation node of type in, with 2 var references
			OperationNode inStatement = feNode.getInStatement();
			String keyName = ((VariableReferenceNode) inStatement.getLeft()).getName();

			// if the key does not exist, create one in the appropriate variable spot
			var location = (localVars != null) ? localVars : globalVariables;
			location.put(keyName, new InterpreterDataType());
			var keyData = location.get(keyName);
			
			// Right side MUST be an array
			if (getIDT(inStatement.getRight().get(), localVars) instanceof InterpreterArrayDataType IADT) {
				// iterate through the map setting the designated variable to the value at the location
				for (String x : IADT.getMap().keySet()) {
					keyData.setData(x); 
					
					ReturnType returnedVal = interpretListOfStatements(feNode.getStatements(), localVars);

					if (returnedVal.getProcess() == processes.BREAK) {
						break;
					} else if (returnedVal.getProcess() == processes.RETURN) {
						return returnedVal;
					}
				}
			} else {
				throw new IllegalArgumentException("A forEach loop must have the rightside be an array");
			}
			return new ReturnType(processes.NORMAL);
		}
		else if(stmt instanceof FunctionCallNode fcNode) {
			String retVal = runFunctionCall(fcNode, localVars);
			return (retVal != null) ? new ReturnType(processes.NORMAL ,retVal) : new ReturnType(processes.NORMAL);
		}
		else if(stmt instanceof IfElseNode ifNode) {
			return returnOfIfElse(ifNode, localVars);
		}
		else if (stmt instanceof ReturnNode rNode) {
			var val = rNode.getValue();
			// return - return type and the value to return if there is one
			return val.isEmpty() ? new ReturnType(processes.RETURN) : new ReturnType(processes.RETURN, getIDT(val.get(), localVars).getData());
		}
		else if (stmt instanceof OperationNode opNode) {
			// pre/post operations are only operation nodes that count as statements
			switch (opNode.getOperator()) {
			case PREDEC, PREINC, POSTDEC, POSTINC:
				getIDT(opNode, localVars);
				return new ReturnType(processes.NORMAL);
			default:
				throw new IllegalArgumentException("Operation of type: '" + opNode.getOperator() + "' - is not able to be processed");
			}
		}
		else {
			throw new IllegalArgumentException("Node of type: " + stmt.getClass() + " - is not able to be processed");
		}
	}
	
	private ReturnType interpretListOfStatements(LinkedList<StatementNode> statements, HashMap<String, InterpreterDataType> localVars) {
		for (StatementNode s : statements) {
			ReturnType returnedVal = processStatement(s, localVars);
			if (returnedVal.getProcess() != processes.NORMAL) {
				return returnedVal;
			}
		}
		return new ReturnType(processes.NORMAL);
	}

	// ------------------JUNIT FUNCTIONS--------------------
	
	
	//------------- TO BE USED WITH JUNIT --------------
	public HashMap<String, DefineFunction> getFunctions() {
		return functions;
	}

	public LineManager getLinerManager() {
		return lineManager;
	}

	public int[] getFieldVars() {
		return new int[] { NF, NR, FNR };
	}

	public HashMap<String, InterpreterDataType> getGlobals() {
		return globalVariables;
	}
}
